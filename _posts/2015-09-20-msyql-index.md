---
layout: post
title:  "mysql 索引使用总结"
date:   2015-09-20 20:00:13
categories: mysql
permalink: /blogs/mysql-index
---

#  索引的种类：
1. B-Three索引
    （1）索引由多列组成，mysql会根据创建表时的索引列的顺序来进行排序，即从索引从左到右的顺序建立。
             B-Tree索引适用于全键值，键值范围或键值前缀查询。
     （2）B-Tree 索引的限制：
              A. 若不是按照索引的最左列开始查找，则无法使用索引。
              B. 不能跳过索引中的列。即使用的索引列是依次相连在一起的，不能出现相间的使用索引，如：使用了索引列的第一，三列，即出现了一到三的跨越，这是不好的使用方式。
              C. 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
              
2. 哈希索引
    基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引计算一个哈希码，哈希吗是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
    （1）哈希索引的限制
          A. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
          B. 哈希索引数据时并不是按照索引值的顺序存储的，所以也就无法用于排序。
          C. 哈希索引页不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容计算哈希值得。如，在数据列（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
          D. 哈希索引只支持等值比较查询，包括=,IN( ), <=>,但不支持任何范围查询，例如:where price > 100.
          E. 访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突时，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
          F. 如果哈希冲突很多，会导致维护操作的代价很高。
     由于以上限制，所以哈希索引只适用于某些特定的场合，例如要存储大量的URL，并根据URL进行搜索查找。若使用B-Tree来存储URL，存储的内容会很大，因为URL本身都很长。当新增一列用于存储URL对应的哈希值就回非常高效。缺点是需要额外的维护哈希表。
3. 空间数据索引( R-Tree)
MyISAM支持和空间数据索引，可以用来地理数据存储，和B-Tree索引不同的是，这类索引无须前缀查询。空间索引会从所有维度来索引数据，查询时可以有效的使用任意维度来组合查询。mysql对GIS支持不够完善，所以开源的数据库中PostgreSql是个比较好的方案。
          
4. 全文索引
全文索引是一种特殊类型的索引，他查找的是文本中的关键词，而不是直接比较索引中的值。

#  高效索引的建立策略
 1. 独立的列
     即索引列不能是表达式的一部分，也不能是函数的参数。例如，常见的错误：
    select actor_id from sakia.actor where actor_id +1 = 5;
    select * from user where to_days(current_date) - to_days(date_col) < 10
 2. 前缀索引和索引选择性
    前缀索引是一种能使索引更小，更快的有效办法，但是一方面也有缺点，mysql无法使用前缀索引做Order by和group by，
也无法使用前缀索引做覆盖扫面。
3. 多列索引
    索引合并策略有时是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：
    （1）当服务齐对多个索引做相交操作时，通常意味着需要包含所有列的多列索引，而不是多个独立的单列索引。
 
  4. 选择合适的索引顺序
     (1) 经验原则
          A  将选择性高的列的索引最前列
          B  需要根据那些运行频率最高的查询来调整索引列的顺序
5. 使用索引扫描来做排序
    mysql 有两种方式可以生成有序的结果：通过排序操作； 或者按索引顺序扫描。若explain出来的type列的值为“index”，则说明mysql使用了索引扫描来做排序。
    扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就回表查询一次对应的行。这基本上都是随机I/O, 因此按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在I/O密集型的工作负载时。
    mysql 可以使用同一个索引既能满足排序，又能用于查找，所以设计索引时应该尽量满足这两个因素。但是只有当索引的列顺序和order by 子句的顺序完全一致，并且所有列的排序方向（倒续或正序）都一样时，mysql才能使用索引来对结果做排序。若查询需要关联多张表，则只有当order by 子句引用的字段全部为第一个表时，才能使用索引做排序。order by 子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则，mysql都需要执行排序操作，而无法利用索引排序。有一种情况下order by 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候，如果where子句或者join子句中对这些列指定了常量，就可以“弥补”索引的不足。
    不能使用索引排序的查询：
     A order by 排序方向和索引顺序不同（索引列都是正序排序的）
     B  order by 子句中引用了一个不在索引中的列
     C where 和order by 中的列无法组合成索引的最左前缀（不能出现索引列跳过的现象）
     D  索引列的第一列上是范围条件，所以无法使用索引的其余列


